#include "Drawer.h"
using namespace std;

Drawer::Drawer()
{
}
Drawer::~Drawer()
{
    glDeleteVertexArrays(id, &vao);
    glDeleteBuffers(id, &vbo);
    glDeleteProgram(program);
    glfwTerminate();
}
int Drawer::initWindow(int width, int height, const char *title)
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    // glfwWindowHint(GLFW_DECORATED, GLFW_FALSE);
    glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);

    window = glfwCreateWindow(width, height, title, NULL, NULL);
    if (window == NULL)
    {
        cout << "create window failed" << endl;
        glfwTerminate();
        return CREATE_WINDOW_FAILED;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, setViewport);
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        cout << "glad load failed" << endl;
        return GLAD_LOAD_FAILED;
    }
    glViewport(0, 0, width, height);
    return 0;
}

int Drawer::linkProgram(const char *fsSource, const char *vsSource)
{
    unsigned int fragmentShader, vertexShader;
    int success;
    char log[512];
    program = glCreateProgram();
    if (compileShader(fsSource, GL_FRAGMENT_SHADER, &fragmentShader))
    {
        return COMPILE_SHADER_FAILED;
    }
    if (compileShader(vsSource, GL_VERTEX_SHADER, &vertexShader))
    {
        return COMPILE_SHADER_FAILED;
    }
    glAttachShader(program, fragmentShader);
    glAttachShader(program, vertexShader);
    glLinkProgram(program);
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success)
    {
        glGetProgramInfoLog(program, 512, NULL, log);
        cout << "link program failed:" << log << endl;
        return LINK_PROGRAM_FAILED;
    }
    glDeleteShader(fragmentShader);
    glDeleteShader(vertexShader);
    return 0;
}
void setViewport(GLFWwindow *window, int width, int height)
{
    glViewport(0, 0, width, height);
}
int Drawer::compileShader(const char *shaderSource, unsigned int type, unsigned int *result)
{
    unsigned int shader = glCreateShader(type);
    int success;
    char log[512];
    glShaderSource(shader, 1, &shaderSource, NULL);
    glCompileShader(shader);
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(shader, 512, NULL, log);
        cout << "compile shader failed:" << log << endl;
        return COMPILE_SHADER_FAILED;
    }
    *result = shader;
    return 0;
}
void Drawer::createVao(float data[], int length, int id, int location)
{
    unsigned int VBO, VAO;
    glGenVertexArrays(id, &VAO);
    glGenBuffers(id, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, length, data, GL_STATIC_DRAW);
    glBindVertexArray(VAO);
    glVertexAttribPointer(location, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glEnableVertexAttribArray(location);
    glBindVertexArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    vao = VAO;
    vbo = VBO;
    id = id;
}
void Drawer::draw()
{
    glClearColor(0.2, 0.1, 0.3, 0.4);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glUseProgram(program);
    glBindVertexArray(vao);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 3);
}
void Drawer::getKeyInput()
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }
}
void Drawer::mainLoop()
{
    while (!glfwWindowShouldClose(window))
    {
        getKeyInput();
        draw();
        glfwSwapBuffers(window);
        glfwPollEvents();
    }
}
int Drawer::linkProgram(unsigned int fragmentShader, unsigned int vertexShader)
{
    int success;
    char log[512];
    program = glCreateProgram();
    glAttachShader(program, fragmentShader);
    glAttachShader(program, vertexShader);
    glLinkProgram(program);
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success)
    {
        glGetProgramInfoLog(program, 512, NULL, log);
        cout << "link program failed:" << log << endl;
        return LINK_PROGRAM_FAILED;
    }
    return 0;
}
// int main()
// {
//     Drawer drawer;

//     const char *const vsSource = "#version 330 core\n"
//                                  "layout (location = 0) in vec3 point;\n"
//                                  "void main()\n"
//                                  "{\n"
//                                  "   gl_Position = vec4(point.x,-point.y,point.z, 1);\n"
//                                  "}\n\0";
//     // const char不能改内容，char * const不能改指向
//     const char *const fsSource = "#version 330 core\n"
//                                  "out vec4 color;\n"
//                                  "void main()\n"
//                                  "{\n"
//                                  "   color = vec4(1, 0.4, 0.5, 1);\n"
//                                  "}\n\0";
//     float data[] = {0, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0};
//     drawer.initWindow(500, 500, "hello world");
//     drawer.linkProgram(fsSource, vsSource);
//     drawer.createVao(data, sizeof(data), 1, 0);
//     drawer.mainLoop();
//     return 0;
// }