#include "LightWindow.h"

static const char *const vertex_shader_path = "dist/shader/phong_shading/vertex_shader.vs";
static const char *const fragment_shader_path = "dist/shader/phong_shading/fragment_shader.fs";
static const char *const light_fragment_shader_path = "dist/shader/phong_shading/light_fragment_shader.fs";
static int WIDTH = 800, HEIGHT = 600;
static Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));
static glm::mat4 projection;

static void _setViewport(GLFWwindow *window, int width, int height)
{
    projection = glm::perspective(glm::radians(camera.getZoom()), (float)width / height, 0.1f, 100.0f);
    WIDTH = width;
    HEIGHT = height;
    glViewport(0, 0, width, height);
}

void mouseMove(GLFWwindow *window, double xpos, double ypos)
{
    camera.ProcessMouseMovement(xpos, ypos);
}
void scroll(GLFWwindow *window, double xoffset, double yoffset)
{
    camera.ProcessMouseScroll(yoffset);
}

LightWindow::LightWindow(/* args */) : GLWindow(WIDTH, HEIGHT, _setViewport), light_color(glm::vec3(0.33f, 0.42f, 0.18f)), light_pos(glm::vec3(1.2f, 1.0f, 2.0f)), object_color(glm::vec3(1.0f, 0.5f, 0.31f)), cube(1)
{
    this->mouseCallback = mouseMove;
    this->scrollCallback = scroll;

    initWindow(WIDTH, HEIGHT, "光照场景");
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClearDepth(1.0f);

    object_shader.readFile(vertex_shader_path, fragment_shader_path);
    light_shader.readFile(vertex_shader_path, light_fragment_shader_path);
    light_shader.useProgram();

    cube.createVAO();
}

LightWindow::~LightWindow()
{
}

void LightWindow::draw()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glm::mat4 model(1.0f);
    glm::mat3 normal_model = glm::transpose(glm::inverse(glm::mat3(model)));
    glm::mat4 view = camera.getViewMatrix();

    object_shader.useProgram();
    object_shader.setUniformMatrix4("model", model);
    object_shader.setUniformMatrix4("projection", projection);
    object_shader.setUniformMatrix4("view", view);
    object_shader.setUniformMatrix3("normalModel", normal_model);
    object_shader.setUniform3fv("lightPos", light_pos);
    object_shader.setUniform3fv("lightColor", light_color);
    object_shader.setUniform3fv("objectColor", object_color);
    object_shader.setUniform3fv("viewPos", camera.getPosition());
    cube.draw();

    model = glm::translate(model, light_pos);
    light_shader.useProgram();
    light_shader.setUniformMatrix4("model", model);
    light_shader.setUniformMatrix4("projection", projection);
    light_shader.setUniformMatrix4("view", view);
    cube.draw();

}

void LightWindow::getKeyInput()
{
    int direction = 0x00;
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
    {
        direction |= _CAMERA_UP;
    }
    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
    {
        direction |= _CAMERA_DOWN;
    }
    if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    {
        direction |= _CAMERA_RIGHT;
    }
    if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
    {
        direction |= _CAMERA_LEFT;
    }
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
    {
        direction |= _CAMERA_FORWARD;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
    {
        direction |= _CAMERA_BACKWARD;
    }
    camera.ProcessKeyboardInput(direction, delta);
}