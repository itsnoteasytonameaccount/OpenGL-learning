
const POSITIVE_RORATE = 0x08, NEG_RORATE = 0xf7
const POSITIVE_DIR = 0x10,
  NEG_DIR = 0xef,
  X = 0x04,
  Y = 0x02,
  Z = 0x01
const U: number = Y | POSITIVE_DIR | POSITIVE_RORATE,
  F: number = Z | POSITIVE_DIR | POSITIVE_RORATE,
  B: number = Z & NEG_DIR | POSITIVE_RORATE,
  L: number = X & NEG_DIR | POSITIVE_RORATE,
  R: number = X | POSITIVE_RORATE | POSITIVE_DIR,
  D: number = Y & NEG_DIR | POSITIVE_RORATE
class PlayCommand {
  public trueCommand: Object
  public constructor() {
    this.trueCommand = {
      U, R, L, D, B, F
    }
  }

  public static reverse_rorate_around_X(direct: number, flag?: boolean): number {
    if (direct & X) {
      return direct
    } else {
      direct = ~X & ~direct & 0x07 | (direct & ~0x07)
    }
    if (Z & direct) {
      if (flag) {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      } else {
        return direct
      }
    } else {
      if (flag) {
        return direct
      } else {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      }
    }
  }
  public static reverse_rorate_around_Y(direct: number, flag?: boolean): number {
    if (direct & Y) {
      return direct
    } else {
      direct = ~Y & ~direct & 0x07 | (direct & ~0x07)
    }
    if (X & direct) {
      if (flag) {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      } else {
        return direct
      }
    } else {
      if (flag) {
        return direct
      } else {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      }
    }
  }
  public static reverse_rorate_around_Z(direct: number, flag?: boolean): number {
    if (direct & Z) {
      return direct
    } else {
      direct = ~Z & ~direct & 0x07 | (direct & ~0x07)
    }
    if (Y & direct) {
      if (flag) {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      } else {
        return direct
      }
    } else {
      if (flag) {
        return direct
      } else {
        return POSITIVE_DIR & ~direct | NEG_DIR & direct
      }
    }
  }
  public static reverse_rorate_around_axis(axis: number, face: number, flag?: boolean): number {
    switch (axis) {
      case X:
        return this.reverse_rorate_around_X(face, flag)
      case Y:
        return this.reverse_rorate_around_Y(face, flag)
      case Z:
        return this.reverse_rorate_around_Z(face, flag)
    }
    return -1
  }
  public static outputCommand(direct: number): String {
    switch (direct) {
      case U:
        return "U"
      case F:
        return "F"
      case D:
        return "D"
      case B:
        return "B"
      case L:
        return "L"
      case R:
        return "R"
      default:
        return "unknown"
    }
  }
  public static outputAxis(direct: number): void {
    let axis: String
    switch (direct & 0x07) {
      case X:
      default:
        axis = "X axis "
        break
      case Y:
        axis = "Y axis "
        break
      case Z:
        axis = "Z axis "
        break
    }
    if (direct & POSITIVE_DIR) {
      axis += "positive direction"
    } else {
      axis += "negtive direction"
    }
    console.log(axis)
  }
}
class Cube {
  cubeData: Array<any>
  colors: Array<String>
  order: number
  constructor({ order = 3, colors = ["red", "orange", "green", "blue", "yellow", "white"] }: any) {
    this.cubeData = [
      POSITIVE_DIR | X,
      NEG_DIR | X,
      POSITIVE_DIR | Y,
      NEG_DIR | Y,
      POSITIVE_DIR | Z,
      NEG_DIR | Z
    ].reduce((result: Array<Object>, face: number, index: number) => {
      result[face] = {
        direct: 0,
        colors: new Array(order * order).fill(index),
        top_direct: ((face & Y & 0x07) == 0 ? X : Y) | POSITIVE_DIR
      }
      return result
    }, [])
    this.colors = colors
    this.order = order
  }
  getLine(face: number, line: number, axis: number): Array<number> {
    let { direct, colors, top_direct, [axis]: cached } = this.cubeData[face]
    const order: number = this.order
    const result: Array<number> = []
    let end: number
    if (!(top_direct & axis)) {
      if (cached) {
        direct = (direct + cached) % 4
      } else {
        cached = 0
        while (top_direct != axis) {
          direct = (direct + 1) % 4
          top_direct = PlayCommand.reverse_rorate_around_axis(face & 0x07, top_direct)
          cached++
        }
        this.cubeData[face][axis] = cached
      }
    }
    switch (direct) {
      case 1:
        for (let i: number = order * (order - 1) + line; i >= 0; i -= order) {
          result.push(colors[i])
        }
      case 2:
        end = (order - 1) * order
        for (let i: number = order * order - 1; i >= end; i--) {
          result.push(colors[i])
        }
      case 3:
        for (let i: number = order * order - 1 - line; i >= 0; i -= order) {
          result.push(colors[i])
        }
        break
      case 0:
      default:
        end = (line + 1) * order
        for (let i = line * order; i < end; i++) {
          result.push(colors[i])
        }
        break
    }
    return result
  }
  setLine(face: number, line: number, replace_colors: Array<number>, axis: number) {
    let { direct, colors, [axis]: cached, top_direct } = this.cubeData[face]
    const order: number = this.order
    if (!(top_direct & axis)) {
      if (cached) {
        direct = (direct + cached) % 4
      } else {
        cached = 0
        while (top_direct != axis) {
          direct = (direct + 1) % 4
          top_direct = PlayCommand.reverse_rorate_around_axis(face & 0x07, top_direct)
          cached++
        }
        this.cubeData[face][axis] = cached
      }
    }
    switch (direct) {
      case 1:
        for (let i: number = 0; i < order; i++) {
          colors[order * (order - 1 - i) + line] = replace_colors[i]
        }
      case 2:
        for (let i: number = 0; i < order; i++) {
          colors[order * order - 1 - i] = replace_colors[i]
        }
      case 3:
        for (let i: number = 0; i < order; i++) {
          colors[order * (order - i) - 1 - line] = replace_colors[i]
        }
        break
      case 0:
      default:
        for (let i: number = 0; i < order; i++) {
          colors[i + line * order] = replace_colors[i]
        }
        break
    }
  }
  draw(gl: WebGL2RenderingContext): void {
  }
  init(gl: WebGL2RenderingContext): any {
    gl.clearColor(0.0, 0.0, 0.0, 1.0)
    gl.clearDepth(1)
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    const source = ``;
    if (shader) {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
    }
  }
}